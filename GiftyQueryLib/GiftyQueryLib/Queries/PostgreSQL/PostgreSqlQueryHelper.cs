using GiftyQueryLib.Builders.PostgreSql;
using GiftyQueryLib.Config;
using GiftyQueryLib.Enums;
using GiftyQueryLib.Exceptions;
using GiftyQueryLib.Translators.Models;
using GiftyQueryLib.Translators.SqlTranslators;
using GiftyQueryLib.Utils;
using System.ComponentModel.DataAnnotations;
using System.Linq.Expressions;
using System.Text;

namespace GiftyQueryLib.Queries.PostgreSQL
{
    /// <summary>
    /// PostgreSQL Query Helper Class
    /// </summary>
    /// <typeparam name="T"></typeparam>
    public class PostgreSqlQueryHelper<T> where T : class
    {
        private readonly PostgreSqlTranslator translator;
        private readonly PostgreSqlConfig config;
        private readonly Type type;

        protected StringBuilder value = new(string.Empty);
        protected bool whereIsUsed = false;
        protected string selectAllMark = string.Empty;
        protected Expression<Func<T, object>>? exceptColumnSelector = null;

        /// <summary>
        /// Constructor
        /// </summary>
        /// <param name="config"></param>
        /// <param name="extraType"></param>
        public PostgreSqlQueryHelper(PostgreSqlConfig config, Type? extraType = null)
        {
            this.translator = new PostgreSqlTranslator(config);
            this.config = config;
            this.type = extraType ?? typeof(T);
        }

        #region Count

        /// <summary>
        /// Parses Count Expression
        /// </summary>
        /// <typeparam name="T"></typeparam>
        /// <param name="columnSelector"></param>
        /// <param name="distinct"></param>
        public virtual void Count(Expression<Func<T, object>>? columnSelector = null, bool distinct = false)
        {
            string sql = "SELECT ";
            string sqlDistinct = distinct ? "DISTINCT " : "";
            string sqlCount = "COUNT({0}) ";
            string? name;

            if (columnSelector is not null)
            {
                var data = translator.Helper.GetMemberData(columnSelector);
                var info = data.MemberInfo;
                var type = data.CallerType?.ToCaseFormat(config.CaseConfig);
                name = info?.Name?.ToCaseFormat(config.CaseConfig);
                sqlCount = string.Format(sqlCount, string.Format(config.ColumnAccessFormat, config.Scheme, type, name));
            }
            else
            {
                name = "all";
                sqlCount = string.Format(sqlCount, "*");
            }

            translator.Helper.AutoGeneratedAlias = (Guid.NewGuid().ToString(), sqlCount);

            sqlCount = string.Format(sqlCount + " AS {0} ", $"count_{name}");

            value = new StringBuilder(sql + sqlDistinct + sqlCount);
        }

        #endregion

        #region Select

        /// <summary>
        /// Parses Select Single Expression
        /// </summary>
        /// <param name="columnSelector"></param>
        /// <param name="distinct"></param>
        public virtual void SelectSingle(Expression<Func<T, object>>? columnSelector = null, bool distinct = false)
        {
            string sql = "SELECT ";
            string sqlDistinct = distinct ? "DISTINCT " : "";

            if (columnSelector is null)
            {
                value = new StringBuilder(sql + sqlDistinct + "1 ");
            }
            else
            {
                var data = translator.Helper.GetMemberData(columnSelector);
                var info = data.MemberInfo;
                var type = data.CallerType?.ToCaseFormat(config.CaseConfig);
                var name = info?.Name?.ToCaseFormat(config.CaseConfig);

                value = new StringBuilder(sql + sqlDistinct + string.Format(config.ColumnAccessFormat, config.Scheme, type, name) + " ");
            }
        }

        /// <summary>
        /// Parses Select Expression
        /// </summary>
        /// <param name="include"></param>
        /// <param name="exclude"></param>
        /// <param name="selectAll"></param>
        /// <param name="distinct"></param>
        public virtual void Select(Expression<Func<T, object>>? include = null, Expression<Func<T, object>>? exclude = null, bool selectAll = false, bool distinct = false)
        {
            string sql = "SELECT ";

            selectAllMark = selectAll ? $"<s_a_{Guid.NewGuid()}>" : string.Empty;

            var parsedSelector = translator.ParseSelector(include, exclude, config: new SelectorConfig { SelectAll = selectAll });

            if (selectAll)
                exceptColumnSelector = exclude;

            string sqlDistinct = distinct ? "DISTINCT " : "";
            string sqlRows = parsedSelector + (selectAll ? selectAllMark : "");
            string sqlFrom = string.Format(" FROM {0}.{1} ", config.Scheme, type.ToCaseFormat(config.CaseConfig));

            value = new StringBuilder(sql + sqlDistinct + sqlRows + sqlFrom);
        }

        #endregion

        #region Insert

        /// <summary>
        /// Composes Insert Query
        /// </summary>
        /// <param name="entities"></param>
        /// <exception cref="BuilderException"></exception>
        public virtual void Insert(params T[] entities)
        {
            if (entities is null || entities.Length == 0)
                throw new BuilderException("At least one entity should be provided");

            var values = new List<string>();
            var nonNullableProps = new HashSet<string>();

            foreach (T entity in entities)
            {
                var props = entity.GetType().GetProperties();

                foreach (var property in props)
                {
                    var value = property.GetValue(entity);

                    if (value is not null)
                    {
                        var attrData = translator.Helper.GetAttrData(property);

                        if (attrData.Value(AttrType.Key) is null && attrData.Value(AttrType.NotMapped) is null)
                        {
                            string propName;
                            var fkAttr = attrData.Value(AttrType.ForeignKey);

                            if (fkAttr is null)
                            {
                                if (property.IsCollection())
                                {
                                    var generic = property.GetGenericArg();

                                    if (Constants.StringTypes.Contains(generic!) || Constants.NumericTypes.Contains(generic!) || attrData.Value(AttrType.Json) is not null)
                                        propName = property.Name.ToCaseFormat(config.CaseConfig);
                                    else
                                        continue;
                                }
                                else
                                    propName = property.Name.ToCaseFormat(config.CaseConfig);
                            }
                            else
                            {
                                if (property.IsCollection())
                                {
                                    var generic = property.GetGenericArg();

                                    if (Constants.StringTypes.Contains(generic!) || Constants.NumericTypes.Contains(generic!))
                                        throw new BuilderException("Primitive-typed collection should not be marked with foreign key attributes");
                                    else
                                    {
                                        // Handle many to many
                                        continue;
                                    }
                                }
                                else
                                    propName = fkAttr.ConstructorArguments[0].Value!.ToString()!.ToCaseFormat(config.CaseConfig);
                            }

                            nonNullableProps.Add(string.Format("{0}", propName));
                        }
                    }
                }
            }

            foreach (T entity in entities)
            {
                var valuesSb = new StringBuilder();
                var entityData = translator.Helper.GetPopertyWithValueOfEntity(entity);
                entityData.ToList().ForEach(pair =>
                {
                    if (!nonNullableProps.Contains(pair.Key))
                        return;

                    var value = pair.Value;
                    var parsedValue = value is null
                        ? "NULL" : string.Format(Constants.StringTypes.Contains(value.GetType())
                            ? "'{0}'" : "{0}", value.ToString());

                    valuesSb.Append(parsedValue + ", ");
                });

                var valuesSql = valuesSb.TrimEndComma();

                values.Add(string.Format("({0})", valuesSql));
            }

            string columnsSql = string.Join(',', nonNullableProps);
            string rowsSql = string.Join(',', values);

            value = new StringBuilder(string.Format("INSERT INTO {0}.{1} ({2}) VALUES {3}", config.Scheme, type.ToCaseFormat(config.CaseConfig), columnsSql, rowsSql));
        }

        #endregion

        #region Update

        /// <summary>
        /// Composes Update Query
        /// </summary>
        /// <param name="entity"></param>
        public virtual void Update(object entity)
        {
            var entityData = translator.Helper.GetPopertyWithValueOfEntity(entity);
            var pairs = new StringBuilder();
            var fType = type.ToCaseFormat(config.CaseConfig);

            entityData.ToList().ForEach(pair =>
            {
                var value = pair.Value;
                var parsedValue = value is null
                    ? "NULL" : string.Format(Constants.StringTypes.Contains(value.GetType())
                        ? "'{0}'" : "{0}", value.ToString());

                pairs.AppendFormat(config.ColumnAccessFormat + " = {3}, ", config.Scheme, fType, pair.Key, parsedValue);
            });

            var pairsSql = pairs.TrimEndComma();

            value = new StringBuilder(string.Format("UPDATE {0}.{1} SET {2} ", config.Scheme, fType, pairsSql));
        }

        /// <summary>
        /// Composes Bulk Update Query
        /// </summary>
        /// <param name="entities"></param>
        /// <returns></returns>
        /// <exception cref="BuilderException"></exception>
        public virtual void UpdateRange(params object[] entities)
        {
            if (entities is null || entities.Length == 0)
                throw new BuilderException("Entity list cannot be null or empty");

            var valuesSetSb = new StringBuilder();
            var propsSb = new StringBuilder();
            var pairsSb = new StringBuilder();
            var tempTable = $"tmp_{Guid.NewGuid().ToString().Split('-')[0]}";
            var fType = type.ToCaseFormat(config.CaseConfig);

            bool propsWritten = false;

            foreach (var entity in entities)
            {
                var valuesSb = new StringBuilder();
                var entityData = translator.Helper.GetPopertyWithValueOfEntity(entity, false);

                entityData.ToList().ForEach(pair =>
                {
                    if (!propsWritten)
                    {
                        var prop = pair.Key.ToCaseFormat(config.CaseConfig);
                        propsSb.Append(prop + ", ");
                        pairsSb.AppendFormat(config.ColumnAccessFormat + " = {3}, ", config.Scheme,
                            fType, prop, tempTable + "." + prop);
                    }

                    var value = pair.Value;
                    var parsedValue = value is null
                        ? "NULL" : string.Format(Constants.StringTypes.Contains(value.GetType())
                            ? "'{0}'" : "{0}", value.ToString());

                    valuesSb.Append(parsedValue + ", ");
                });

                propsWritten = true;

                var valuesSql = valuesSb.TrimEndComma();

                valuesSetSb.AppendFormat("({0}), ", valuesSb.TrimEndComma());
            }

            var valuesSetSql = valuesSetSb.TrimEndComma();
            var propsSql = propsSb.TrimEndComma();
            var pairsSql = pairsSb.TrimEndComma();

            value = new StringBuilder(string.Format("UPDATE {0}.{1} SET {2} FROM (VALUES {3}) AS {4} ({5})",
                config.Scheme, fType, pairsSql, valuesSetSql, tempTable, propsSql));
        }

        #endregion

        #region Delete

        /// <summary>
        /// Composes Delete Query
        /// </summary>
        public virtual void Delete()
        {
            value = new StringBuilder(string.Format("DELETE FROM {0}.{1} ", config.Scheme, type.ToCaseFormat(config.CaseConfig)));
        }

        #endregion

        #region Join

        /// <summary>
        /// Parses Join Expression
        /// </summary>
        /// <typeparam name="U"></typeparam>
        /// <param name="selector"></param>
        /// <param name="joinType"></param>
        /// <exception cref="BuilderException"></exception>
        public virtual void Join<U>(Expression<Func<U, object>> selector, JoinType joinType = JoinType.Inner)
        {
            var selectorData = translator.Helper.GetMemberData(selector);
            var memberType = selectorData.MemberType;
            var keyProp = memberType?
                .GetProperties().FirstOrDefault(prop => prop.GetCustomAttributes(true).FirstOrDefault(attr => attr is KeyAttribute) is not null);

            if (keyProp is null)
                throw new BuilderException($"Key attribute is absent in related table");

            if (memberType == null || !memberType.IsClass)
                throw new BuilderException($"Unable to join using non-reference properties");

            string expresstionTypeName = selectorData.CallerType!.ToCaseFormat(config.CaseConfig);
            string memberTypeName = memberType.Name.ToCaseFormat(config.CaseConfig);
            string keyPropName = keyProp.Name.ToCaseFormat(config.CaseConfig);

            var foreignKeyAttributeData = selectorData.MemberInfo?
                .GetCustomAttributesData().FirstOrDefault(it => config.ForeignKeyAttributes.Any(attr => it.AttributeType == attr));

            string foreignKeyName = string.Empty;

            if (foreignKeyAttributeData is null)
            {
                foreignKeyName = string.Format(config.ColumnAccessFormat, config.Scheme, expresstionTypeName, memberTypeName + "_" + keyPropName);
            }
            else
            {
                foreignKeyName = string.Format(config.ColumnAccessFormat, config.Scheme, expresstionTypeName, foreignKeyAttributeData.ConstructorArguments[0].Value!.ToString()!.ToCaseFormat(config.CaseConfig));
            }

            string inner = string.Format(config.ColumnAccessFormat, config.Scheme, memberTypeName, keyPropName);
            string sqlJoinType = joinType.ToString().ToUpper();

            value.AppendFormat("{0} JOIN {1}.{2} ON {3} = {4} ", sqlJoinType, config.Scheme, memberTypeName, foreignKeyName, inner);

            if (!string.IsNullOrEmpty(selectAllMark))
            {
                string sqlRows = "," + translator.ParseSelector(null, exceptColumnSelector, memberType, new SelectorConfig { SelectAll = true }) + selectAllMark;
                value = new StringBuilder(value.ToString().Replace(selectAllMark, sqlRows));
            }
        }

        #endregion

        #region Where

        /// <summary>
        /// Parses Where Expression
        /// </summary>
        /// <param name="condition"></param>
        public virtual void Where(Expression<Func<T, bool>> condition)
        {
            value.Append(string.Format(whereIsUsed ? " AND {0} " : "WHERE {0} ", translator.Translate<T>(condition)));
            whereIsUsed = true;
        }

        #endregion

        #region Group By

        /// <summary>
        /// Parses Group By Expression
        /// </summary>
        /// <param name="include"></param>
        /// <param name="exclude"></param>
        /// <returns></returns>
        public virtual void Group(Expression<Func<T, object>> include, Expression<Func<T, object>>? exclude = null)
        {
            var parsed = translator.ParseSelector(include, exclude, config: new SelectorConfig
            {
                AllowMethodCall = false,
                AllowBinary = false,
                UseAliases = false
            });
            value.AppendFormat("GROUP BY {0} ", parsed);
        }

        #endregion

        #region Having

        /// <summary>
        /// Parses Having Expression
        /// </summary>
        /// <param name="condition"></param>
        public virtual void Having(Expression<Func<T, bool>> condition)
        {
            value.AppendFormat("HAVING {0} ", translator.Translate<T>(condition));
        }

        #endregion

        #region Order By

        /// <summary>
        /// Parses Order By Expression
        /// </summary>
        /// <param name="columnSelector"></param>
        /// <param name="orderType"></param>
        /// <exception cref="BuilderException"></exception>
        public virtual void Order(Expression<Func<T, object>> columnSelector, OrderType orderType = OrderType.Asc)
        {
            if (columnSelector is null)
                throw new BuilderException("Row selector must be provided");

            var parsed = translator.ParseSelector(columnSelector, config: new SelectorConfig
            {
                AllowBinary = false,
                AllowConstant = false
            });

            var orderRowsSql = string.Join(',', parsed.Split(',').Select(it => it + " " + orderType.ToString().ToUpper()));

            if (orderType != OrderType.None)
                value.AppendFormat("ORDER BY {0} ", orderRowsSql);
        }

        #endregion

        #region Limit

        /// <summary>
        /// Composes Limit Query
        /// </summary>
        /// <param name="limit"></param>
        public virtual void Limit(int limit)
        {
            value.Append(string.Format("LIMIT {0} ", limit));
        }

        #endregion

        #region Offset

        /// <summary>
        /// Composes Offset Query
        /// </summary>
        /// <param name="limit"></param>
        public virtual void Offset(int skipped)
        {
            value.Append(string.Format("OFFSET {0} ", skipped));
        }

        #endregion

        #region Build

        /// <summary>
        /// Returns parsed sql string
        /// </summary>
        /// <returns></returns>
        public override string ToString()
        {
            var str = value.ToString();
            if (!string.IsNullOrEmpty(selectAllMark) || exceptColumnSelector is not null)
                str = str.Replace(selectAllMark, string.Empty);

            return str;
        }

        #endregion
    }
}
